{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Group Terminal is a minimalistic, terminal-based group chat system designed for testing and prototyping AI service integrations. Most group chat systems require authentication, databases, and user management before you can test a single message handler or prototype collaboration of user groups with AI. Group Terminal eliminates this complexity by providing a minimal WebSocket-based chat server and Rich-powered terminal clients that let you focus on testing your integration logic rather than infrastructure setup.</p> <p>Note</p> <p>Group Terminal uses termios for terminal control and is Unix-specific. It will not work on Windows systems.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install group-terminal\n</code></pre>"},{"location":"#quickstart","title":"Quickstart","text":"<p>The included example demonstrates how to launch a chat server and register a message handler. The handler echoes back each received message with the pattern \"I received '{message}' from {username}\". This showcases a basic service integration pattern.</p> <p>Here's the essential code:</p> examples/app.py<pre><code>import asyncio\n\nfrom group_terminal.server import ChatServer\n\nclass ChatApp:\n    def __init__(self, host: str, port: int):\n        self._server = ChatServer(host=host, port=port)\n        self._server.add_handler(self._handle_message)\n\n    @property\n    def server(self):\n        return self._server\n\n    async def _process_message(self, content: str, username: str):\n        # potentially long-running operation ...\n        response = f\"I received '{content}' from {username}\"\n        # send response to chat clients\n        await self._server.send_message(response, sender=\"agent\", agent=True)\n\n    async def _handle_message(self, content: str, username: str):\n        # Handles messages generated by chat clients i.e. users. A\n        # handler is called sequentially in message arrival order.\n        # This is the same order as seen in the chat client.\n\n        # Operations that require preserving message arrival order\n        # (adding to a queue, ...) should be done here. Long-running\n        # message processing should be done asynchronously to prevent\n        # blocking the message receiver loop.\n        asyncio.create_task(self._process_message(content, username))\n\n\napp = ChatApp(host=\"0.0.0.0\", port=8723)\nawait app.server.start()\nawait app.server.join()\n</code></pre> <p>See the complete example for full implementation details.</p> <p>Start the server:</p> <pre><code>python examples/app.py\n</code></pre> <p>In separate terminals, launch two clients with different usernames:</p> <pre><code>python -m group_terminal.client --username alice\npython -m group_terminal.client --username bob\n</code></pre> <p>The screenshots below show a conversation where <code>alice</code> sends \"Hey everyone! How's it going?\" and <code>bob</code> replies \"Pretty good!\". Notice the color coding: your own messages appear in orange, messages from other users in cyan, and agent responses in green. The message handler echoes each message back to all connected clients.</p> <p><code>alice</code>'s view:</p> <p></p> <p><code>bob</code>'s view:</p> <p></p>"},{"location":"api/client/","title":"Client","text":""},{"location":"api/client/#group_terminal.client.ChatClient","title":"group_terminal.client.ChatClient","text":"<pre><code>ChatClient(username: str, host: str = 'localhost', port: int = 8723, **terminal_kwargs)\n</code></pre> <p>               Bases: <code>MessageSender</code></p> <p>Terminal-based chat client for testing and demonstration purposes.</p> <p>Provides a Rich-based terminal interface for interacting with a group of users and services connected to a ChatServer instance. Intended for testing and demonstration only, not for production use in applications. The client is typically started from the command line using: <code>python -m group_terminal.client --username &lt;username&gt;</code>.</p> Note <p>This client uses termios for terminal control and is Unix-specific. It will not work on Windows systems.</p> <p>Initialize the chat client.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>The name of the this client's user.</p> required <code>host</code> <code>str</code> <p>The hostname or IP address of the chat server.</p> <code>'localhost'</code> <code>port</code> <code>int</code> <p>The port number of the chat server.</p> <code>8723</code>"},{"location":"api/client/#group_terminal.client.ChatClient.connect","title":"connect  <code>async</code>","text":"<pre><code>connect() -&gt; bool\n</code></pre> <p>Connect to the chat server.</p>"},{"location":"api/client/#group_terminal.client.ChatClient.join","title":"join  <code>async</code>","text":"<pre><code>join()\n</code></pre> <p>Join a connected client until disconnected.</p>"},{"location":"api/server/","title":"Server","text":""},{"location":"api/server/#group_terminal.server.ChatServer","title":"group_terminal.server.ChatServer","text":"<pre><code>ChatServer(host: str = 'localhost', port: int = 8723)\n</code></pre> <p>WebSocket-based group chat server for testing and demonstration purposes.</p> <p>Manages client connections, message broadcasting, and custom message handlers. Supports multiple clients connecting with distinct usernames to participate in a shared chat session. Multiple connections with the same username are not allowed.</p> Example <p>Basic server with a message handler::</p> <pre><code>async def handle_message(content: str, username: str):\n    print(f\"Received '{content}' from {username}\")\n\nserver = ChatServer(host=\"0.0.0.0\", port=8723)\nserver.add_handler(handle_message)\nawait server.start()\nawait server.join()\n</code></pre> <p>Initialize the chat server.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The hostname or IP address to bind the server to. Use \"0.0.0.0\" to accept connections from any network interface.</p> <code>'localhost'</code> <code>port</code> <code>int</code> <p>The port number to listen on for WebSocket connections.</p> <code>8723</code>"},{"location":"api/server/#group_terminal.server.ChatServer.add_handler","title":"add_handler","text":"<pre><code>add_handler(handler: MessageHandler)\n</code></pre> <p>Register a callback to handle incoming chat messages.</p> <p>Handlers are called sequentially in the order that messages arrive from clients. This is the same order that messages appear in chat clients. For operations that preserve message arrival order (such as adding to a queue), perform them directly in the handler. For long-running message processing, delegate to background tasks to avoid blocking the message receiver loop.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>MessageHandler</code> <p>Callback function that receives message content and username. Multiple handlers can be registered and will be called in registration order for each message.</p> required"},{"location":"api/server/#group_terminal.server.ChatServer.start","title":"start  <code>async</code>","text":"<pre><code>start()\n</code></pre> <p>Start the chat server asynchronously.</p> <p>Returns immediately after launching the server task. The server runs in the background and begins accepting WebSocket connections.</p>"},{"location":"api/server/#group_terminal.server.ChatServer.stop","title":"stop  <code>async</code>","text":"<pre><code>stop()\n</code></pre> <p>Stop the server gracefully.</p> <p>Signals the server to shut down and waits for the server task to complete.</p>"},{"location":"api/server/#group_terminal.server.ChatServer.join","title":"join  <code>async</code>","text":"<pre><code>join()\n</code></pre> <p>Wait for the server to complete.</p> <p>Blocks until <code>stop</code> is called from another task. If you have other means to keep your main coroutine alive, calling <code>join</code> is not necessary.</p>"},{"location":"api/server/#group_terminal.server.MessageHandler","title":"group_terminal.server.MessageHandler  <code>module-attribute</code>","text":"<pre><code>MessageHandler = Callable[[str, str], Awaitable[None]]\n</code></pre> <p>Callback function for handling incoming chat messages.</p> <p>Handlers receive messages in the order they arrive and are called sequentially. For long-running operations, implementations should delegate work to background tasks to avoid blocking the message receiver loop.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The message content sent by a user</p> required <code>username</code> <code>str</code> <p>The username of the user who sent the message</p> required"}]}